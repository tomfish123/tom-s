# File:   radio_autoencoder.py
# Brief:  Simulates a radio link over AWGN channel for Uncoded, Hamming 
#         coded and Neural network autoencoded radio links.
#         Reproduces the results obtained in 
#         "An Introduction to Deep Learning for the Physical Layer",
#         Timothy J. O'Shea, Jakob Hoydis
# Author: Vidit Saxena
#
# Usage:  python radio_autoencoder.py
#
# -------------------------------------------------------------------------
#
# Copyright (C) 2016 CC0 1.0 Universal (CC0 1.0) 
#
# The person who associated a work with this deed has dedicated the work to
# the public domain by waiving all of his or her rights to the work 
# worldwide under copyright law, including all related and neighboring 
# rights, to the extent allowed by law.
#
# You can copy, modify, distribute and perform the work, even for commercial 
# purposes, all without asking permission.
#
# See the complete legal text at 
# <https://creativecommons.org/publicdomain/zero/1.0/legalcode>
#
# -------------------------------------------------------------------------

from src import uncoded, hamming
from src import autoencoder

from matplotlib import pyplot as plt

''' Function:    _bler_vs_snr_hamming_autoenc(block_size, channel_use, snrs_db)
    Description: Block error ratio (BLER) vs Signal to Noise Ratio (SNR) 
                 curves for standard channel coding using Hamming codes, 
                 and for 'learnt' optimal representation that are obtained 
                 by training a neural network based autoencoder. Additive 
                 White Gaussian Noise (AWGN) channel is assumed. 
'''


def _bler_vs_snr_hamming_autoenc(block_size, channel_use, snrs_db):
    channel_use = {4: 7}  # Mapping to get length of Hamming codeblock from block length
    
    '''BLER for uncoded BPSK over AWGN channel'''
    print('-------Evaluating BLER for Uncoded (%d,%d) over AWGN-------' % (block_size, block_size))
    bler_unc = [uncoded.block_error_ratio_uncoded_awgn(snr, block_size) for snr in snrs_db]
    
    '''BLER for Hamming coded bits over AWGN channel'''
    print('-------Evaluating BLER for Hamming (%d,%d) over AWGN-------' % (channel_use[block_size], block_size))
    bler_hamming = [hamming.block_error_ratio_hamming_awgn(snr, block_size) for snr in snrs_db]
    
    '''BLER for Autoencoder coded bits over AWGN channel'''
    print('-------Evaluating BLER for Autoencoder (%d,%d) over AWGN-------' % (channel_use[block_size], block_size))
    batch_size = int(20 / block_size)
    nrof_steps = int(200000 / block_size)
    bler_autoenc = autoencoder.block_error_ratio_autoencoder_awgn(snrs_db, block_size, channel_use[block_size],
                                                                  batch_size, nrof_steps)
    
    print('-------Plotting results-------')
    plt.figure()
    plt.grid(True)
    plt.semilogy(snrs_db, bler_unc, ls='-', c='b')
    plt.semilogy(snrs_db, bler_hamming, ls='--', c='g')
    plt.semilogy(snrs_db, bler_autoenc, ls='--', c='r', marker='o')
    plt.xlabel('SNR [dB]')
    plt.ylabel('Block Error Ratio')
    plt.legend(['Uncoded BPSK (%d,%d)' % (block_size, block_size),
                'Hamming (%d,%d)' % (channel_use[block_size], block_size),
                'Autoencoder (%d,%d)' % (channel_use[block_size], block_size)],
               loc='lower left')
    plt.title('BLER vs SNR for Autoencoder and several baseline communication schemes')
    
    return (bler_hamming, bler_autoenc)


def _bler_vs_snr_hamming_autoenc_RTN(block_size, channel_use, snrs_db):
    channel_use = {4: 7}  # Mapping to get length of Hamming codeblock from block length

    '''BLER for Autoencoder with RTN coded bits over AWGN channel'''
    print('-------Evaluating BLER for Autoencoder (%d,%d) with RTN over AWGN-------' % (
    channel_use[block_size], block_size))
    batch_size = int(20 / block_size)
    nrof_steps = int(200000 / block_size)
    bler_autoenc_RTN = autoencoder.block_error_ratio_autoencoder_awgn_RTN(snrs_db, block_size, channel_use[block_size],
                                                                          batch_size, nrof_steps)
    
    '''BLER for uncoded BPSK over AWGN channel'''
    print('-------Evaluating BLER for Uncoded (%d,%d) over AWGN-------' % (block_size, block_size))
    bler_unc = [uncoded.block_error_ratio_uncoded_awgn(snr, block_size) for snr in snrs_db]
    
    '''BLER for Hamming coded bits over AWGN channel'''
    print('-------Evaluating BLER for Hamming (%d,%d) over AWGN-------' % (channel_use[block_size], block_size))
    bler_hamming = [hamming.block_error_ratio_hamming_awgn(snr, block_size) for snr in snrs_db]
    
    '''BLER for Autoencoder coded bits over AWGN channel'''
    print('-------Evaluating BLER for Autoencoder (%d,%d) over AWGN-------' % (channel_use[block_size], block_size))
    batch_size = int(20 / block_size)
    nrof_steps = int(200000 / block_size)
    bler_autoenc = autoencoder.block_error_ratio_autoencoder_awgn(snrs_db, block_size, channel_use[block_size],
                                                                  batch_size, nrof_steps)
    
    print('-------Plotting results-------')
    plt.figure()
    plt.grid(True)
    plt.semilogy(snrs_db, bler_unc, ls='-', c='b')
    plt.semilogy(snrs_db, bler_hamming, ls='--', c='g')
    plt.semilogy(snrs_db, bler_autoenc, ls='--', c='r', marker='o')
    plt.semilogy(snrs_db, bler_autoenc_RTN, ls='--', c='b', marker='o')
    plt.xlabel('SNR [dB]')
    plt.ylabel('Block Error Ratio')
    plt.legend(['Uncoded BPSK (%d,%d)' % (block_size, block_size),
                'Hamming (%d,%d)' % (channel_use[block_size], block_size),
                'Autoencoder (%d,%d)' % (channel_use[block_size], block_size),
                'AUtoencoder with RTN (%d, %d)' % (channel_use[block_size], block_size)],
               loc='lower left')
    plt.title('BLER vs SNR for Autoencoder with RTN and several baseline communication schemes')
    
    return (bler_hamming, bler_autoenc, bler_autoenc_RTN)


''' Function:    _bler_vs_snr_hamming_autoenc(block_size, channel_use, snrs_db)
    Description: Block error ratio (BLER) vs Signal to Noise Ratio (SNR) curves 
                 for uncoded transmission, and for 'learnt' optimal 
                 representations of the transmitted bits that are obtained by 
                 training a neural network based autoencoder. Additive White 
                 Gaussian Noise (AWGN) channel is assumed. 
'''


def _bler_vs_snr_uncoded_autoenc(block_sizes, snrs_db):
    plt.figure()
    plt.grid(True)
    legend_strings = []
    colors = iter(list(['b', 'r', 'g', 'b', 'm']))
    for block_size in block_sizes:
        '''BLER for uncoded bits over AWGN channel'''
        print('-------Evaluating BLER for Uncoded BPSK (%d,%d) over AWGN-------' % (block_size, block_size))
        bler_unc = [uncoded.block_error_ratio_uncoded_awgn(snr, block_size) for snr in snrs_db]
        
        '''BLER for Autoencoder coded  bits over AWGN channel'''
        print('-------Evaluating BLER for Autoencoder (%d,%d) over AWGN-------' % (block_size, block_size))
        batch_size = 10 / block_size
        nrof_steps = 100000 / block_size
        bler_autoenc = autoencoder.block_error_ratio_autoencoder_awgn(snrs_db, block_size, block_size, batch_size,
                                                                      nrof_steps)
        
        print('-------Plotting results-------')
        color = next(colors)
        plt.semilogy(snrs_db, bler_unc, ls='-', c=color)
        plt.semilogy(snrs_db, bler_autoenc, ls='--', c=color, marker='o')
        
        legend_strings.append('Uncoded BPSK (%d,%d)' % (block_size, block_size))
        legend_strings.append('Autoencoder (%d,%d)' % (block_size, block_size))
    
    plt.xlabel('SNR [dB]')
    plt.ylabel('Block Error Ratio')
    plt.legend(legend_strings, loc='lower left')
    plt.title('BLER vs SNR for Autoencoder and BPSK')


if __name__ == '__main__':
    snrs_db = range(-4, 9)
    
    # '''BLER for block size 4 with Autoencoder and Hamming'''
    # block_size = 4
    # channel_use = 7
    # _bler_vs_snr_hamming_autoenc(block_size, channel_use, snrs_db)
    
    # '''BLER for block sizes 2 and 8 with uncoded and Autoencoder'''
    # block_sizes = [2, 8]
    # _bler_vs_snr_uncoded_autoenc(block_sizes, snrs_db)

    '''BLER for block size 4 with Autoencoder and Hamming and Autoencoder with RTN'''
    block_size = 4
    channel_use = 7
    _bler_vs_snr_hamming_autoenc_RTN(block_size, channel_use, snrs_db)
    
    plt.show()
